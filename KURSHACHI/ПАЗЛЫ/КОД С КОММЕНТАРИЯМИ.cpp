//---------------------------------------------------------------------------
//подключаем все нужные библиотеки
#include <vcl.h>
#pragma hdrstop
#include "Unit1.h"
#include "math.hpp"
#pragma package(smart_init)
#pragma resource "*.dfm"
//---------------------------------------------------------------------------
#define W 4//описываем кол-во клеток 
#define H 4//по ширине и длинне
//---------------------------------------------------------------------------
TForm1 *Form1;//переменная нашего окна
byte wc, hc;//wc и hc размеры клеток
byte pole[H][W];//делаем матрицу 
int ex, ey;//координаты для пустой клетки
bool GameOver;//хранит состояние игры true если игры закончен, иначе false 
AnsiString fn;//строчка с именем файла
TSearchRec SearchRec;//результат поиска файла
Graphics::TBitmap *pic;//загруженное изображение
//---------------------------------------------------------------------------
//функция вызывается при запуске программы
__fastcall TForm1::TForm1(TComponent* Owner)
	: TForm(Owner)
{
	pic = new Graphics::TBitmap();//создаем переменную для изображения
}
//---------------------------------------------------------------------------
//функция новой игры
void TForm1::NewGame()
{
    if (OpenDialog1->Execute())//открваем окно выбора файла
	{
		fn = OpenDialog1->FileName;//берем имя выброного файла
	}

	try
	{
        pic->LoadFromFile(fn);//загружаем файл по имени
	}
	catch (EFOpenError &e)//если выбросилось ошибка показываем оповещение
	{
		MessageDlg("Ошибка при загрузке файла",
			mtWarning, TMsgDlgButtons()<<mbOK<<mbHelp,0);
		return;
	}

	wc = pic->Width / W;//определяем размер клетки
	hc = pic->Height / H;//по высоте и широте

	ClientWidth = wc * W;//устанавливаем размер окна по изображения
	ClientHeight = hc * H;//по высоте и широт

	int k = 1;
	for (int i = 0; i < H; i++)//задаем два цикла
		for (int j = 0; j < W; j++)//и пробегаемся по мматрице поля
			pole[i][j] = k++;//присваивая каждой клетке её порядкой номер

	GameOver = false;//говорим что игра не окончена
	Mixer();//вызываем функция перемешки клеток
	ShowPole();//отрисовываем поле
}
//---------------------------------------------------------------------------
//функция для перемешивания клеток
void TForm1::Mixer()
{
	int x1, y1;//координаты пустой клетки
	int x2, y2;//коориднаты этой клетки нужо переместить
	int d;//направление перемещения относительно пустой клетки

	Randomize();//оптимизируем функция генерации случайных чисел

	x1 = 3, y1 = 3;//ставим положение координат
	
	for (int i = 0; i < 150; i++)//передвигаем случайно клетки 150 раз
	{
		do
		{
			x2 = x1;//присваиваем координат перестановки
			y2 = y1;//x и y
			d = RandomRange(1,5);//задаем случайное направление
			switch(d)// в зависимости от напрвления
			{
				//увеличиваем или уменьшаем нужные координаты
				case 1: x2--; break;
				case 2: x2++; break;
				case 3: y2--; break;
				case 4: y2++; break;
            }
		} while ((x2 < 0) || (x2 >= W) || (y2 < 0 || (y2 >= H)));//делаем это пока мы попадаем в клетки

		//здесь мы определяем фишку которую
		//надо переместить в пустую клетку
		pole[y1][x1] = pole[y2][x2];
		pole[y2][x2] = 16;
		//присваиваем координаты
		x1 = x2;
		y1 = y2;
	}
	//запоминаем координаты пустой клетки
	ex = x1;
	ey = y1;
}
//---------------------------------------------------------------------------
//функция для отрисвки поля в окне
void TForm1::ShowPole()
{
	TRect src, dst;//фрагмент карттинки и область её отображения, 

	int sx, sy;//координаты для определения угла клетки

	for (int i = 0; i < H; i++) 
	{							//проходимся по матрице через 2 цикла
		for (int j = 0; j < W; j++) 
		{
			sx = ((pole[i][j]-1) % W) * wc;//преобразуем фрагмент картинки
			sy = ((pole[i][j]-1) / H) * hc;//в координаты левого верхнего угла

			src = Bounds(sx, sy, wc, hc);//по координатам угла создаем фрагмент
			dst = Bounds(j*wc, i*hc, wc, hc);//и область отображения

			if ((pole[i][j]) != 16 || GameOver)//если клетка не пустая или игра окончена
				Canvas->CopyRect(dst, pic->Canvas, src);//рисуем клетка с картинкой
			else//иначе если клетка пустая
			{
				Canvas->Brush->Style = bsSolid;//стави стиль кисти
				Canvas->Brush->Color = clBtnFace;//стави цвет кисти
				Canvas->Rectangle(dst);//рисуем пустую клетку
            }
		}
	}

	if (N4->Checked)//если включени параметр номера
	{
		Canvas->Brush->Style = bsClear;//ставим кисти прозрачность
		Canvas->Font->Size = 20;//задаем размер шрифта
		Canvas->Font->Color = clWhite;//задаем цвет шрифта
		for (int i = 0; i < H; i++)//проходмся по клеткам
			for (int j = 0; j < W; j++)//через два цикла
				Canvas->TextOutA(wc*j, hc*i, IntToStr(pole[i][j]));//и рисуемм цфиру в зависимости от номера клетки
	}
}
//---------------------------------------------------------------------------
//функция вызывается при нажатии мышкой на экран
void __fastcall TForm1::FormMouseDown(TObject *Sender, TMouseButton Button, TShiftState Shift,
		  int X, int Y)
{
	int cx, cy;//координаты клетки
	cx = X / wc;//высчитываем в какую клетки мы нажали
	cy = Y / hc;//по x и y
	Move(cx, cy);//и посылаем координаты в функция Move
}
//---------------------------------------------------------------------------
//функция Move передвигает клетку, координаты которой в неё послали
void TForm1::Move(int cx, int cy)
{
	if ((abs(cx - ex) == 1) && (cy - ey == 0) ||
		(abs(cy - ey) == 1) && (cx - ex == 0))//если клека рядом с пустой клеткой
	{
		pole[ey][ex] = pole[cy][cx];//перемещаем клетки
		pole[cy][cx] = 16;//ставим пустую
		ex = cx;//запоминаем координаты пустой
		ey = cy;//по x и y
		ShowPole();//вызываем функцию отрисовки поля
		if (Finish())//если игра закончена
		{
			GameOver = true;//стави true
			ShowPole();//показываем поле
			//показываем окно оповещения
			int r = MessageDlg("Цель достигнута! Еще раз?", mtInformation,
								TMsgDlgButtons() << mbYes << mbNo, 0);
			if (r = mrNo)//если нажали no
				Form1->Close();//закываем программу
			else//иначе если нажали yes
			{
				NewGame();//запускаем новую игру
				ShowPole();//рисуем поле
            }
		}
	}
}
//---------------------------------------------------------------------------
//функция Finish возращает true если игра закончена(тоесть картинка собрана)
bool TForm1::Finish()
{
	bool result;//логический результат
	int row, col;//кол-во рядов и столбцов
	int k = 1;//подсчет правильно расставенных фигурок

	result = true;
	for (row = 0; row < H; row++)
	{							//пробегаемся по матрице через 2 цикла
		for (col = 0; col < W; col++) 
		{
			if (pole[row][col] == k)//если клетка на своём месте
				k++;//увеличиваем счетчик
			else//иначе
			{    
				result = false;//стави false
				break;//вылетаем с цикла
            }
		}
		if(!result)//проверяем результат
			break;//и еще раз вылетаем с цикла
	}
	return result;//возращаем результат в место вызова функции
}
//---------------------------------------------------------------------------
//функция вызывается автоматически windows для отрисвки программы
void __fastcall TForm1::FormPaint(TObject *Sender)
{
	ShowPole();//рисуем поле
}
//---------------------------------------------------------------------------
//при нажатии на новую игру в меню
void __fastcall TForm1::N1Click(TObject *Sender)
{
	NewGame();//создаем новую игру
}
//---------------------------------------------------------------------------
//при нажатии на справку
void __fastcall TForm1::N3Click(TObject *Sender)
{
	ShowMessage("Автор: Егор Горишний БИ1602");//показываем окно информации
}
//---------------------------------------------------------------------------
//при нажатии на параметр номера
void __fastcall TForm1::N4Click(TObject *Sender)
{
	N4->Checked = !N4->Checked;//вкл или выкл галочку
	ShowPole();//показываем поле	
}
//---------------------------------------------------------------------------


